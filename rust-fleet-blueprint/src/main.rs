//! Entry point demonstrating how the control plane binary might be structured.
//! The goal is to illustrate library choices and orchestration flow without
//! implementing the entire backend. Each function is heavily commented to
//! explain the reasoning behind design decisions and future work.

mod database;
mod orchestrator;
mod vpn;

use clap::{Parser, Subcommand};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

/// Command-line interface definition for the prototype binary.
/// Administrators can experiment with device enrollment workflows locally
/// while the full control plane is being implemented.
#[derive(Debug, Parser)]
#[command(author, version, about = "Rust Fleet Control Prototype", long_about = None)]
struct Cli {
    /// Enables verbose logging if provided. Useful during development to
    /// understand the flow of async operations and external API calls.
    #[arg(short, long, global = true)]
    verbose: bool,

    /// Groups high-level actions administrators might perform. These map to
    /// REST/gRPC endpoints in the eventual production deployment.
    #[command(subcommand)]
    command: Commands,
}

/// Supported subcommands for the CLI demonstration.
#[derive(Debug, Subcommand)]
enum Commands {
    /// Simulate the enrollment of a new device and persist the metadata to
    /// SurrealDB. This mirrors the onboarding handshake between openBalena and
    /// a device but is OS-agnostic.
    EnrollDevice {
        /// Unique human-readable identifier for the device.
        #[arg(long)]
        device_name: String,

        /// WireGuard public key generated by the device agent during bootstrap.
        #[arg(long)]
        public_key: String,
    },
    /// Preview how a deployment job could be dispatched to a device via the
    /// orchestrator abstraction. The actual job execution is stubbed out but
    /// demonstrates request validation and queueing patterns.
    DispatchJob {
        /// Identifier of the target device.
        #[arg(long)]
        device_id: String,

        /// OCI image reference representing the workload to deploy via Docker.
        #[arg(long)]
        image: String,
    },
    /// Issue WireGuard configuration for a new peer. This connects the control
    /// plane with the VPN authority logic handled by `vpn::WireGuardAuthority`.
    IssueVpnConfig {
        /// Device identifier for context in audit logs.
        #[arg(long)]
        device_id: String,
    },
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();

    // Initialize tracing so developers can observe structured logs. We prefer
    // using `tracing` over `log` because it integrates seamlessly with async
    // Rust and OpenTelemetry exporters.
    let tracing_level = if cli.verbose { "debug" } else { "info" };
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(tracing_level))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // Establish a single SurrealDB connection pool for the duration of the
    // command. In a real service, this would be managed via Axum middleware.
    let db = database::Database::connect("ws://127.0.0.1:8000", "rust_fleet").await?;

    match cli.command {
        Commands::EnrollDevice {
            device_name,
            public_key,
        } => {
            // Persist metadata and generate the next actions the agent should
            // perform. The stubbed response demonstrates how SurrealDB's
            // flexible schema and SQL-like language simplify prototyping.
            let record = db
                .register_device(&device_name, &public_key)
                .await?;
            tracing::info!(?record, "device enrolled");
        }
        Commands::DispatchJob { device_id, image } => {
            // The orchestrator abstracts how jobs are queued and executed.
            // It could back onto RabbitMQ, Redis Streams, or even a custom
            // scheduler. For the blueprint we only log the intent.
            let orchestrator = orchestrator::JobOrchestrator::default();
            orchestrator.queue_deployment(&device_id, &image).await?;
        }
        Commands::IssueVpnConfig { device_id } => {
            // Request the VPN authority to provision WireGuard configuration.
            let authority = vpn::WireGuardAuthority::default();
            let config = authority.issue_peer_config(&device_id).await?;
            tracing::info!(%device_id, config = %config, "issued wireguard config");
        }
    }

    Ok(())
}
